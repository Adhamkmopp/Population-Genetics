---
title: "Admixture Analysis"
output: github_document
---
###Library loadup
```{r setup}

knitr::opts_chunk$set(fig.width = 20, fig.height = 10)
library("Matrix")
library("survival")
library("snpStats")
library("RColorBrewer")
```

### Data Input

Files generated by admixture (Q-files) are the building blocks for the admixture plot. They contain probabilities/ratios for each individual as predicted by ADMIXTURE. Each row represents an individual, and each column, a predicted population. For example, a completely non-hybridized individual would have 0.999 in the first column, and 0.001 in the second column for k=2 (grants_filtered.2.Q).
```{r}
species <- read.plink('grants_filtered')
localities <- read.plink('localities')
snpk2=read.table("grants_filtered.2.Q")
snpk3=read.table("grants_filtered.3.Q")
snpk4=read.table("grants_filtered.4.Q")
snpk5=read.table("grants_filtered.5.Q")
df <-read.table(file='localities.fam', sep=" ")
```

## Extracting Localities

Localities are found in the fam file, and are read as a dataframe (multiple lists under one big list, because the fam file in itself contains more than one list represented by columns, and seperated by spaces). The species extracted previously from above contains the pedigrees (individual names) in the pedigree list, contained in the fam list, contained in the species object. A list within a list within a list, basically.

Names and localities will be used later to define the axes in the generated plot
```{r}
df <-read.table(file='localities.fam', sep=" ")
locality <-df$V1
names=species$fam$pedigree
```

## Switching The Misplaced Individuals

We knew later that several individuals had to be moved. The trouble is, we cannot simply move and switch them. We first store the individuals we have to move in a seperate container, safetly overwrite their values in the snpk list with the ones we wish to move, and then, again, overwrites the ones that were moved with the ones from the seperate container. The monstrosity below describes these steps for all snpk lists. There are easier and more efficient ways of doing this, but generally the easier and more efficient it is, the more complicated it gets in terms of implementation. There is likely an implemented method for doing this in R itself.

On a final note, corresponding localities are also switched at the bottom of the code for correct axis alignment.

```{r pressure}
first<- snpk2[22,]
second <-snpk2[23,]
snpk2[22,] = snpk2[36,]
snpk2[23,] = snpk2[37,]
snpk2[36,] = first
snpk2[37,] = second
first<- snpk3[22,]
second <-snpk3[23,]
snpk3[22,] = snpk3[36,]
snpk3[23,] = snpk3[37,]
snpk3[36,] = first
snpk3[37,] = second
first<- snpk4[22,]
second <-snpk4[23,]
snpk4[22,] = snpk4[36,]
snpk4[23,] = snpk4[37,]
snpk4[36,] = first
snpk4[37,] = second
first<- snpk5[22,]
second <-snpk5[23,]
snpk5[22,] = snpk5[36,]
snpk5[23,] = snpk5[37,]
snpk5[36,] = first
snpk5[37,] = second
local_switch <- locality[22:23]
locality[22:23] <-locality[36:37]
locality[36:37] <-local_switch
```
### Plotting The Histograms

We finally get to plotting the histograms. Each function takes in different variables for customization. There are far too many variables to describe in detail, but the basic gist of it is that we have set the data we have manipulated above to be represented as four subplots in one figure, with vertically aligned axes names, custom colors and legends. Description, input variables and sometimes examples of what each function can do can be accessed by appending "?" to the function name. For example, ?par will give a description of the function and a detailed explanation of each variable input. Par controls the graphical parameters for each object on the plot. We have used it repeatedly to set the positions for each histrogram, and in specifying the alignment of the axis labels.
```{r}
cols<-brewer.pal(n=6,name="Set1")
par(mfrow=c(4,1), xpd = T, mar = par()$mar + c(0,0,0,2))
par(fig=c(0, 1, 0, 0.25))
barplot(t(as.matrix(snpk2)), col= cols, border=NA,
        names.arg=(names), cex.names=0.8, las=2, ylab="Ancestry, k=2")
legend(x=115, y=1,box.lwd=0.5,legend=c("granti","petersii"), fill = c(cols[2],cols[1]))
par(las=2)
axis(3, seq(0.5, 113.4,1.2) , cex.axis=0.8, tck=FALSE, labels =locality)

par(fig=c(0, 1, 0.3, 0.55),new=TRUE)
barplot(t(as.matrix(snpk3)), col= cols, border=NA, names.arg=(names), cex.names=0.8, las=2, ylab="Ancestry,k=3")
legend(x=115, y=1,legend=c("granti","petersii", 'notata'), fill = c(cols[2],cols[1], cols[3], cols[4]))
par(las=2)
axis(3, seq(0.5, 113.4,1.2) , tck=FALSE, labels =locality)

par(fig=c(0, 1, 0.6, 0.85),new=TRUE)
barplot(t(as.matrix(snpk4)), col= c(cols[4],cols[2],cols[3],cols[1]),border=NA, names.arg=(names), cex.names=0.8, las=2, ylab="Ancestry, k=4")
legend(x=115, y=1,legend=c("granti","petersii", "notata", "robertsii"), fill = c(cols[2],cols[1], cols[3],cols[4]))
par(las=2)
axis(3, seq(0.5, 113.4,1.2) , tck=FALSE, labels =locality)
```

```{r}
par(mfrow=c(4,1), xpd = T, mar = par()$mar + c(0,0,0,2))
par(fig=c(0, 1, 0.3, 0.55))
barplot(t(as.matrix(snpk5)), col= c(cols[3],cols[2],cols[5],cols[1], cols[4]),
        border=NA,  names.arg=(names), cex.names=0.8, las=2, ylab="Ancestry, k=5")
legend(x=115, y=1,legend=c("granti","petersii", 'notata', 'thomson', 'robertsii'), fill = c(cols[2],cols[1],cols[3],cols[5],cols[4]))
par(las=2)
axis(3, seq(0.5, 113.4,1.2) , cex.axis=0.8, tck=FALSE, labels =locality)
```


